# HoppingRabbit AI 前端开发规范

> 版本: 1.1.0  
> 最后更新: 2026-01-16  
> 维护者: @hexiangyang
>
> ⚠️ **重要**: 前后端交互相关规范请参阅 [前后端交互规范.md](./前后端交互规范.md)

---

## 一、问题复盘与经验沉淀

### 1.1 最近修复的问题

| 问题 | 根因 | 解决方案 | 影响范围 |
|------|------|----------|----------|
| Crop/删除操作刷新后丢失 | SyncManager 300ms 防抖 + localStorage 大数据超限 | 过滤大字段后保存到 localStorage | `editor-store.ts`, `sync-manager.ts` |
| 播放头拖拽音视频不同步 | 缺少统一 seek 函数 + audio 预加载不完整 | `seekToTime()` 统一管理 + canplaythrough Promise | `VideoCanvas.tsx` |
| 音频提取时间偏移 | FFmpeg input seeking 精度不足 | 改用 output seeking | `tasks.py` |
| 视频加载等待65秒（20秒视频） | 使用 `canplaythrough` 需完全缓冲 | 改用 `canplay` (readyState >= 2) | `VideoCanvas.tsx`, `ProcessingView.tsx` |
| ProcessingView 预加载未共享 | 各组件独立创建 video 元素 | 全局 `globalMediaCache` + 导出 `preloadVideoToCache()` | `VideoCanvas.tsx`, `ProcessingView.tsx` |
| console.log 暴露给生产用户 | 未区分开发/生产环境 | 条件 `debugLog` 模式 | 多个组件 |
| 弹窗引导状态刷新丢失 | 使用 localStorage 而非数据库 | 添加 wizard_completed 到 projects 表 | `editor-store.ts`, `projects.py` |
| 关键帧不生效 | offset 计算未除以 clip.duration | 修正关键帧加载和插值逻辑 | `editor-store.ts`, `keyframe-interpolation.ts` |
| 第一个 clip 只有声音 | 视频元素未正确挂载/预热 | 检查 container.appendChild 和预热流程 | `VideoCanvasStore.tsx` |

### 1.2 经验教训

1. **状态持久化必须有双重保障**：后端同步 + 本地缓存（localStorage/IndexedDB）
2. **大数据字段不能直接序列化**：waveformData、transcript 等需过滤后再存储
3. **异步操作必须考虑竞态条件**：使用 debounce/throttle + ref 跟踪最新状态
4. **媒体操作需要预加载保证**：不能假设资源已就绪
5. **区分「硬性条件慢」与「代码问题慢」**：大文件/网络慢可接受，但代码不应放大延迟
6. **视频加载优先使用 canplay 而非 canplaythrough**：后者需完全缓冲，会造成不必要等待
7. **跨组件共享媒体缓存**：避免重复创建 video 元素，使用全局 cache 共享预加载结果
8. **生产环境禁止 console.log**：使用 `debugLog` 条件日志，仅开发环境输出
9. **用户状态优先存数据库**：wizard_completed 等状态必须存数据库，不能依赖 localStorage
10. **时间单位必须明确标注**：毫秒 vs 秒 vs 归一化 0-1，在代码注释中明确说明

### 1.3 前后端交互常见陷阱 🔴

> 详细规范见 [前后端交互规范.md](./前后端交互规范.md)

| 陷阱 | 错误做法 | 正确做法 |
|------|----------|----------|
| **时间单位** | `video.currentTime = timeMs` | `video.currentTime = timeMs / 1000` |
| **字段命名** | 混用 snake_case/camelCase | 后端 snake_case，前端 camelCase，有映射层 |
| **关键帧 offset** | `offset = timeMs / clipDuration` | `offset = (timeMs - clip.start) / clipDuration` |
| **sourceStart** | 与 start 混淆 | sourceStart 是媒体内时间，start 是时间线位置 |
| **视频加载** | 使用 canplaythrough | 使用 canplay（readyState >= 3） |

---

## 二、核心模块依赖图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          Editor Page                                 │
│                     (editor/page.tsx)                               │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        Editor Store                                  │
│                   (editor-store.ts)                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │
│  │    State     │  │   Actions    │  │  Computed    │              │
│  │  - clips     │  │  - addClip   │  │  - timeline  │              │
│  │  - tracks    │  │  - removeClip│  │  - duration  │              │
│  │  - currentTime│ │  - updateClip│  │              │              │
│  └──────────────┘  └──────────────┘  └──────────────┘              │
└─────────────────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│  SyncManager    │  │  LocalStorage   │  │   IndexedDB     │
│ (sync-manager)  │  │   (备份缓存)    │  │  (MediaCache)   │
│ - 300ms 防抖    │  │ - pendingSync   │  │ - 媒体文件缓存  │
│ - 版本冲突处理  │  │ - 24h 过期      │  │                 │
└─────────────────┘  └─────────────────┘  └─────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         Backend API                                  │
│              /api/projects/{id}/state (PATCH)                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.1 核心状态流转

```
用户操作 → Action → set(state) → _addOperation → SyncManager.addOperation
                         │                              │
                         ▼                              ▼
                    localStorage              IndexedDB (操作队列)
                    (完整状态备份)                      │
                                                       ▼
                                              300ms 防抖后
                                                       │
                                                       ▼
                                              Backend API 同步
                                                       │
                                              ┌────────┴────────┐
                                              ▼                 ▼
                                           成功              失败
                                              │                 │
                                              ▼                 ▼
                                    markLocalStorageSynced   重试/离线模式
```

---

## 三、开发规范

### 3.1 状态管理规范

#### ✅ 正确做法

```typescript
// 1. Action 内先 set() 更新状态，再调用 _addOperation
updateClip: (id, updates) => {
  // Step 1: 同步更新本地状态
  set((state) => ({
    clips: state.clips.map(c => c.id === id ? { ...c, ...updates } : c),
  }));
  
  // Step 2: 触发同步（此时 get() 能拿到最新状态）
  get()._addOperation('UPDATE_CLIP', { id, ...mappedUpdates });
},

// 2. 使用细粒度 selector 避免不必要的重渲染
const clips = useEditorStore((s) => s.clips);
const currentTime = useEditorStore((s) => s.currentTime);
// ❌ 避免: const { clips, currentTime } = useEditorStore();
```

#### ❌ 禁止做法

```typescript
// 1. 不要在 action 外直接修改状态
useEditorStore.setState({ clips: [...] }); // ❌

// 2. 不要假设异步操作的顺序
async someAction() {
  await api.call1();
  // ❌ 此时状态可能已被其他操作修改
  const { clips } = get(); 
}

// 3. 不要在 localStorage 存储大数据
saveToLocalStorage(clips); // ❌ 如果 clips 包含 waveformData
```

### 3.2 组件开发规范

#### 性能优化清单

| 规则 | 说明 | 示例 |
|------|------|------|
| useMemo 缓存计算结果 | 避免每次渲染重复计算 | `useMemo(() => clips.filter(...), [clips])` |
| useCallback 缓存函数 | 避免子组件不必要重渲染 | `useCallback(() => {...}, [deps])` |
| 细粒度 selector | 只订阅需要的状态 | `useEditorStore(s => s.currentTime)` |
| 常量提取 | 静态对象/样式提取到组件外 | `const STYLE = { ... };` |

#### 代码审查清单

```markdown
## PR 自检清单

### 状态管理
- [ ] Action 是否先 set() 再 _addOperation()
- [ ] 是否使用细粒度 selector
- [ ] 大数据字段是否从序列化中过滤

### 性能
- [ ] 计算密集型逻辑是否用 useMemo
- [ ] 事件处理函数是否用 useCallback
- [ ] 是否有不必要的 useEffect 依赖

### 异步操作
- [ ] 是否处理了竞态条件
- [ ] 是否有 loading/error 状态
- [ ] 组件卸载后是否取消异步操作

### 媒体相关
- [ ] 是否等待 canplaythrough 事件
- [ ] 是否处理 seeking/seeked 事件
- [ ] 是否考虑了加载失败的情况
```

### 3.3 文件命名规范

```
frontend/src/features/editor/
├── components/           # UI 组件
│   ├── VideoCanvas.tsx   # PascalCase
│   └── ClipToolbar.tsx
├── store/
│   └── editor-store.ts   # kebab-case
├── lib/
│   ├── sync-manager.ts   # 工具类
│   └── media-cache.ts
├── hooks/
│   └── use-editor.ts     # use- 前缀
└── types/
    └── clip.ts           # 类型定义
```

---

## 四、自检测流程

### 4.1 修改前检查

```bash
# 1. 确认影响范围
git diff --stat

# 2. 运行类型检查
pnpm type-check

# 3. 运行 lint
pnpm lint
```

### 4.2 核心功能回归测试清单

每次修改 `editor-store.ts` 或核心组件后，必须手动验证：

#### 状态持久化

| 测试项 | 操作 | 预期结果 |
|--------|------|----------|
| Clip 删除持久化 | 删除 clip → 刷新页面 | clip 仍被删除 |
| Crop 持久化 | 裁剪视频 → 刷新页面 | 裁剪效果保留 |
| 离线操作恢复 | 断网 → 操作 → 恢复网络 | 操作自动同步 |

#### 播放控制

| 测试项 | 操作 | 预期结果 |
|--------|------|----------|
| 播放头拖拽 | 拖拽 timeline 播放头 | 视频 + 音频同步跳转 |
| 播放/暂停 | 空格键 | 视频 + 音频同步播放/暂停 |
| 循环播放 | 播放到末尾 | 自动停止或循环 |

#### Clip 操作

| 测试项 | 操作 | 预期结果 |
|--------|------|----------|
| 分割 | 在 clip 中间分割 | 产生两个 clip，时间正确 |
| 移动 | 拖拽 clip 到新位置 | 位置更新，无重叠 |
| 调整时长 | 拖拽 clip 边缘 | 时长更新，字幕同步 |

### 4.3 Console 日志检查点

修改后运行时检查以下日志：

```javascript
// localStorage 保存
[LocalStorage] 已保存状态: X clips, pendingSync=true

// 项目加载
[LoadProject] localState: { pendingSync: true/false, clipsCount: X }
[LoadProject] 使用本地未同步数据 / 使用服务器数据

// 同步状态
[SyncManager] 同步中: X 个操作, 版本 Y
[SyncManager] 同步成功: 新版本 Z
```

### 4.4 自动化测试（建议补充）

```typescript
// __tests__/editor-store.test.ts
describe('Editor Store', () => {
  describe('Clip Operations', () => {
    it('should persist clip deletion to localStorage', () => {
      // TODO: 实现
    });
    
    it('should restore pending changes after refresh', () => {
      // TODO: 实现
    });
  });
  
  describe('Sync Manager', () => {
    it('should debounce operations', () => {
      // TODO: 实现
    });
    
    it('should handle offline mode', () => {
      // TODO: 实现
    });
  });
});
```

---

## 五、关键代码位置索引

| 功能 | 文件 | 关键函数/变量 |
|------|------|---------------|
| 状态持久化 | `editor-store.ts` | `saveToLocalStorage()`, `loadFromLocalStorage()` |
| 同步管理 | `sync-manager.ts` | `SyncManager`, `addOperation()`, `sync()` |
| Clip 操作 | `editor-store.ts` | `addClip()`, `removeClip()`, `updateClip()` |
| 播放控制 | `VideoCanvas.tsx` | `seekToTime()`, `syncAudioClips()` |
| 媒体缓存 | `media-cache.ts` | `MediaCache`, `getOrFetch()` |
| 后端同步 | `projects.py` | `save_project_state()` |
| **关键帧系统** | `editor-store.ts` | `addKeyframe()`, `updateKeyframe()`, `deleteKeyframe()` |
| **关键帧属性按钮** | `PropertyKeyframeButton.tsx` | `PropertyKeyframeButton`, `PropertyKeyframeSlider` |
| **变换面板** | `TransformPanel.tsx` | `TransformPanel` |
| **关键帧类型** | `keyframe.ts` | `KeyframeProperty`, `getKeyframeStatusAt()` |

---

## 六、关键帧系统设计

### 6.1 设计理念（类剪映风格）

关键帧功能按照剪映的交互模式进行重构：
- **细粒度关键帧按钮**：每个可动画属性（缩放、位置、旋转、不透明度等）旁边都有一个菱形关键帧按钮
- **自动添加关键帧**：当属性已有关键帧时，在新位置修改值会自动添加新关键帧
- **状态可视化**：按钮显示三种状态
  - 灰色空心：当前位置无关键帧
  - 青色实心：当前位置有关键帧
  - 黄色：在两个关键帧之间（正在插值）

### 6.2 核心组件

```
┌─────────────────────────────────────────────────────────────────┐
│                    TransformPanel                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 缩放    ◆ ─────────────────────────── 100%              │    │
│  │         [━━━━━━━━━━━━━━━━━━━━━━━━━━━━━]                 │    │
│  │         ◆ 已启用关键帧动画                              │    │
│  └─────────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 位置 X  ◇ ─────────────────────────── [  0  ]           │    │
│  │ 位置 Y  ◇ ─────────────────────────── [  0  ]           │    │
│  └─────────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 旋转    ◆ ─────────────────────────── 0°                │    │
│  │         [━━━━━━━━━━━━━━━━━━━━━━━━━━━━━]                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ 不透明度 ◇ ────────────────────────── 100%              │    │
│  │         [━━━━━━━━━━━━━━━━━━━━━━━━━━━━━]                 │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘

◆ = 当前位置有关键帧（点击删除）
◇ = 当前位置无关键帧（点击添加）
```

### 6.3 使用流程

1. **添加第一个关键帧**
   - 将播放头移动到目标位置
   - 调整属性值（如缩放到 50%）
   - 点击属性旁边的 ◇ 按钮，添加关键帧

2. **创建动画效果**
   - 将播放头移动到另一位置
   - 修改属性值（如缩放到 150%）
   - 系统自动在新位置添加关键帧
   - 播放时，属性会在两个关键帧之间平滑过渡

3. **删除关键帧**
   - 将播放头移动到关键帧位置（按钮变为 ◆）
   - 点击按钮删除关键帧

### 6.4 组件架构

```typescript
// PropertyKeyframeButton - 属性级别的关键帧按钮
<PropertyKeyframeButton
  clipId="clip-1"
  property="scale_x"
  currentValue={1.5}
  disabled={!isInRange}
/>

// PropertyKeyframeSlider - 带关键帧的滑块控制
<PropertyKeyframeSlider
  label="缩放"
  clipId="clip-1"
  property="scale_x"
  value={scale}
  onChange={handleScaleChange}
  min={0.1}
  max={3}
/>
```

---

## 七、变更日志

### 2026-01-13 (v1.2.0)
- **优化**: 视频加载从 `canplaythrough` 改为 `canplay`，减少等待时间 50+ 秒
- **新增**: `globalMediaCache` 全局媒体缓存，`preloadVideoToCache()` 跨组件共享
- **新增**: `debugLog` 条件日志模式，生产环境自动静默
- **重构**: 提取 `calcClipTransformStyle()` 消除重复变换计算逻辑
- **文档**: 补充媒体加载最佳实践和性能归因原则

### 2026-01-12 (v1.1.0)
- **重构**: 关键帧系统按剪映风格重新设计
- **新增**: `PropertyKeyframeButton` - 属性级别的关键帧按钮组件
- **新增**: `PropertyKeyframeSlider` - 带关键帧的滑块控制组件
- **新增**: `TransformPanel` - 变换与动画面板（支持关键帧）
- **新增**: `KeyframeStatus` 类型和 `getKeyframeStatusAt()` 辅助函数
- **优化**: 修改属性值时自动添加关键帧（当已启用动画时）

### 2026-01-12 (v1.0.0)
- **新增**: localStorage 保存时过滤大数据字段（waveformData, transcript, thumbnail）
- **新增**: 调试日志追踪状态持久化流程
- **修复**: Crop 和删除操作刷新后丢失问题
- **文档**: 创建开发规范文档

---

## 八、联系与反馈
